import * as React from 'react';
import { useState, useEffect, useRef, useCallback, memo } from 'react';

const cache = new Map();

// Custom hook for fetching data from API while handling loading and error states and caching the response
const useFetchData = (url, key, dependencyProps = []) => {
    const [data, setData] = useState();
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState("");
    const [refetchIndex, setRefetchIndex] = useState(0);
    useEffect(() => {
        const controller = new AbortController();
        if (cache.has(key)) {
            setData(JSON.parse(cache.get(key)));
            return;
        }
        setLoading(true);
        fetch(url, { credentials: "include", signal: controller.signal })
            .then(async (res) => {
            const data = await res.json();
            if (!res.ok) {
                throw new Error(data.message || "Errro while fetching!");
            }
            else {
                setData(data);
                cache.set(key, JSON.stringify(data));
            }
        })
            .catch((error) => {
            if (error.name !== "AbortError") {
                setError(error.message || "Something went wrong!");
            }
        })
            .finally(() => setLoading(false));
        return () => {
            controller.abort();
        };
    }, [refetchIndex, ...dependencyProps]);
    const refetch = () => {
        cache.delete(key);
        setRefetchIndex((prevIndex) => prevIndex + 1);
    };
    const clearCache = () => {
        cache.delete(key);
    };
    return { data, loading, error, refetch, clearCache };
};

const errorMessages = {
    length: "at least 8 characters",
    number: "a number",
    specialChar: "a special",
    capitalLetter: "a capital",
    lowercaseLetter: "a lowercase",
};

const isIncludeNumber = (password) => {
    const regex = /\d/; // This regular expression matches any digit (0-9)
    return regex.test(password); // This will return true if the password includes a number, and false otherwise
};
const isIncludeSpecialChar = (password) => {
    const specialCharRegex = /[ `!@#$%^&*()_+\-=\[\]{};':"\\|,.<>\/?~]/; // This regular expression matches any special character
    return specialCharRegex.test(password); // This will return true if the password includes a special character, and false otherwise
};
const isIncludeCapitalLetter = (password) => {
    const capitalLetterRegex = /[A-Z]/; // This regular expression matches any capital letter (A-Z)
    return capitalLetterRegex.test(password); // This will return true if the password includes a capital letter, and false otherwise
};
const isIncludeLowercaseLetter = (password) => {
    const lowercaseLetterRegex = /[a-z]/; // This regular expression matches any lowercase letter (a-z)
    return lowercaseLetterRegex.test(password); // This will return true if the password includes a lowercase letter, and false otherwise
};
const isValidEmail = (email) => {
    const emailRegex = /\S+@\S+\.\S+/;
    return emailRegex.test(email);
};
const isValidUsername = (username) => {
    const usernameRegex = /^[a-zA-Z0-9]+$/;
    return usernameRegex.test(username);
};
const isValidUrl = (url) => {
    try {
        new URL(url);
        return true;
    }
    catch (_) {
        return false;
    }
};
// 10 digit phone number
const isValidPhoneNumber = (phoneNumber) => {
    const regex = /^\d{10}$/;
    return regex.test(phoneNumber);
};
// YYYY-MM-DD Format
const isValidDate = (date) => {
    const regex = /^\d{4}-\d{2}-\d{2}$/;
    return regex.test(date);
};
// HH:MM Format
const isValidTime = (time) => {
    const regex = /^\d{2}:\d{2}$/;
    return regex.test(time);
};
// YYYY-MM-DDTHH:MM Format
const isValidDateTime = (dateTime) => {
    const regex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}$/;
    return regex.test(dateTime);
};
const isDateBetween = (date, startDate, endDate) => {
    const targetDate = new Date(date);
    const start = new Date(startDate);
    const end = new Date(endDate);
    return start <= targetDate && targetDate <= end;
};

const useFileHandler = (type, limitInMb = 5, maxFiles = 10) => {
    const initialFile = (type === "multiple" ? [] : null);
    const initialPreview = (type === "multiple" ? [] : null);
    const [error, setError] = useState(null);
    const [file, setFile] = useState(initialFile);
    const [preview, setPreview] = useState(initialPreview);
    const changeHandler = (e) => {
        if (!e.target.files)
            return;
        if (type === "single") {
            const singleFile = e.target.files[0];
            if (e.target.files.length > 1) {
                return setError("Cannot upload more than 1 file, please select type as 'Multiple'");
            }
            if (singleFile.size > 1024 * 1024 * limitInMb) {
                return setError("File size too large");
            }
            const reader = new FileReader();
            reader.readAsDataURL(singleFile);
            reader.onloadend = () => {
                setPreview(reader.result);
            };
            setFile(singleFile);
        }
        if (type === "multiple") {
            const files = Array.from(e.target.files);
            if (maxFiles && files.length > maxFiles) {
                return setError(`Maximum ${maxFiles} files allowed`);
            }
            for (const item of files) {
                if (item.size > 1024 * 1024 * limitInMb) {
                    setError("File size too large");
                    return;
                }
                const reader = new FileReader();
                reader.readAsDataURL(item);
                reader.onloadend = () => {
                    setPreview((prev) => {
                        if (Array.isArray(prev)) {
                            return [...prev, reader.result];
                        }
                        else
                            return [reader.result];
                    });
                };
                setFile((prev) => {
                    if (Array.isArray(prev)) {
                        return [...prev, item];
                    }
                    else
                        return [item];
                });
            }
        }
    };
    return {
        file,
        preview,
        error,
        changeHandler,
    };
};
const useStrongPassword = () => {
    const [error, setError] = useState("");
    const [value, setValue] = useState("");
    const changeHandler = (e) => {
        const val = e.target.value;
        setValue(val);
        const errors = [];
        if (val.length < 8)
            errors.push(errorMessages.length);
        if (!isIncludeNumber(val))
            errors.push(errorMessages.number);
        if (!isIncludeSpecialChar(val))
            errors.push(errorMessages.specialChar);
        if (!isIncludeCapitalLetter(val))
            errors.push(errorMessages.capitalLetter);
        if (!isIncludeLowercaseLetter(val))
            errors.push(errorMessages.lowercaseLetter);
        setError(errors.length > 0
            ? `Password must include ${errors.join(", ")} character`
            : "");
    };
    return {
        error,
        value,
        changeHandler,
    };
};
const useInputValidation = (initialVal, validator = () => undefined) => {
    const [value, setValue] = useState(initialVal);
    const [error, setError] = useState("");
    const changeHandler = (e) => {
        let newValue;
        if (typeof value === "number") {
            newValue = Number(e.target.value);
        }
        else {
            newValue = e.target.value;
        }
        setValue(newValue);
        const validationResult = validator(newValue);
        if (validationResult) {
            setError(validationResult.errorMessage);
        }
        else {
            setError("");
        }
    };
    return {
        value,
        changeHandler,
        error,
    };
};

const useConfirmModal = ({ title = "Confirm Delete", subtitle = "Are you sure you want to delete?", confirmHandler, }) => {
    const modalRef = useRef(null);
    const [isOpen, setIsOpen] = useState(false);
    const showModal = () => setIsOpen(true);
    const closeModal = () => setIsOpen(false);
    const closeHandler = (e) => {
        if (!modalRef.current)
            return;
        const dialogDimension = modalRef.current?.getBoundingClientRect();
        if (e.clientX < dialogDimension.left ||
            e.clientX > dialogDimension.right ||
            e.clientY < dialogDimension.top ||
            e.clientY > dialogDimension.bottom)
            closeModal();
    };
    const handler = () => {
        closeModal();
        confirmHandler();
    };
    const ConfirmModal = ({ containerStyles = {}, noBtnStyles = {}, yesBtnStyles = {}, subtitleStyles = {}, titleStyles = {}, containerClassName, }) => (React.createElement("section", { onKeyDown: (e) => e.preventDefault(), onClick: closeHandler, style: {
            display: isOpen ? "block" : "none",
            height: "100vh",
            width: "100%",
            position: "fixed",
            top: 0,
            left: 0,
        } },
        React.createElement("article", { style: {
                height: "100%",
                width: "100%",
                backgroundColor: "rgba(0,0,0,0.8)",
                backdropFilter: "blur(2px)",
            } }),
        React.createElement("div", { className: `_6pp-confirm-modal ${containerClassName}`, style: {
                width: "20rem",
                backgroundColor: "white",
                padding: "1rem",
                borderRadius: "0.25rem",
                border: "none",
                position: "fixed",
                top: "50%",
                left: "50%",
                zIndex: 20,
                transform: "translate(-50%,-50%)",
                ...containerStyles,
            }, ref: modalRef },
            React.createElement("h5", { style: {
                    fontFamily: "sans-serif",
                    textTransform: "uppercase",
                    ...titleStyles,
                } }, title),
            React.createElement("p", { style: { fontFamily: "monospace", margin: "1rem", ...subtitleStyles } }, subtitle),
            React.createElement("div", { style: {
                    display: "flex",
                    gap: "1rem",
                    marginTop: "1rem 0",
                    float: "right",
                } },
                React.createElement("button", { style: {
                        border: "none",
                        outline: "none",
                        cursor: "pointer",
                        padding: "0.5rem 1rem",
                        borderRadius: "5px",
                        backgroundColor: "inherit",
                        color: "rgba(0,0,0,0.9)",
                        transition: "all 0.3s",
                        ...noBtnStyles,
                    }, autoFocus: true, onClick: closeModal }, "No"),
                React.createElement("button", { style: {
                        border: "none",
                        outline: "none",
                        cursor: "pointer",
                        borderRadius: "5px",
                        padding: "0.5rem 1rem",
                        backgroundColor: "rgba(0,0,0,0.9)",
                        color: "white",
                        transition: "all 0.3s",
                        ...yesBtnStyles,
                    }, onClick: handler }, "Yes")))));
    return { ConfirmModal, showModal, close };
};

const useRating = ({ IconFilled, IconOutline, maxRating = 5, value = 0, selectable = false, styles = {}, }) => {
    if (maxRating < 1)
        throw new Error("maxRating should be greater than 0");
    if (value > maxRating)
        throw new Error("value should be less than Max Rating");
    const [rating, setRating] = useState(value);
    const handleClick = (newRating) => {
        if (!selectable)
            return;
        setRating(newRating);
    };
    useEffect(() => {
        setRating(value);
    }, [value]);
    const Ratings = () => (React.createElement("div", { style: {
            display: "flex",
            flexDirection: "row",
            alignItems: "center",
            justifyContent: "center",
            ...styles,
        } }, Array.from({ length: maxRating }).map((_, i) => (React.createElement("span", { style: {
            cursor: selectable ? "pointer" : "unset",
        }, key: i, onClick: () => handleClick(i + 1) },
        i < rating && React.createElement("span", null, IconFilled),
        i >= rating && React.createElement("span", null, IconOutline))))));
    return { Ratings, rating, setRating };
};

const useInfiniteScrollBottom = (urlWithEndpoint, pageQueryKeyword, limitQueryKeyword, limit, listClassName, totalPages = 1) => {
    const [data, setData] = useState([]);
    const [page, setPage] = useState(1);
    const [hasMore, setHasMore] = useState(true);
    const [loading, setLoading] = useState(false);
    const [error, setError] = useState();
    const timeoutId = useRef(null);
    const fetchData = useCallback(async () => {
        try {
            setLoading(true);
            const response = await fetch(`${urlWithEndpoint}?${pageQueryKeyword}=${page}&${limitQueryKeyword}=${limit}`, { credentials: "include" });
            if (!response.ok)
                throw new Error("Something went wrong");
            const newData = await response.json();
            setData((oldData) => [...oldData, ...newData]);
            setHasMore(newData.length > 0);
        }
        catch (error) {
            setError(error || "Something went wrong");
        }
        finally {
            setLoading(false);
        }
    }, [page, limit, urlWithEndpoint, pageQueryKeyword, limitQueryKeyword]);
    useEffect(() => {
        fetchData();
    }, [fetchData]);
    useEffect(() => {
        const loadMore = () => {
            if (timeoutId.current) {
                clearTimeout(timeoutId.current);
            }
            timeoutId.current = setTimeout(() => {
                if (totalPages === page)
                    return;
                setPage((oldPage) => oldPage + 1);
            }, 200);
        };
        const observerDown = new IntersectionObserver((entries) => {
            if (entries[0].isIntersecting && hasMore && !loading) {
                loadMore();
            }
        }, {
            rootMargin: "100px",
        });
        // Observe the last list item
        const lastListItem = document.querySelector(`.${listClassName}:last-of-type`);
        if (lastListItem) {
            observerDown.observe(lastListItem);
        }
        return () => {
            observerDown.disconnect();
            if (timeoutId.current)
                clearTimeout(timeoutId.current);
        };
    }, [totalPages, page, hasMore, loading]);
    return {
        loading,
        hasMore,
        page,
        error,
        data,
        setData,
    };
};
const useInfiniteScrollTop = (containerRef, totalPages, page, setPage, newData, shouldReverse = false) => {
    const [data, setData] = useState([]);
    const debounceTimer = useRef(null);
    const handleScroll = useCallback(() => {
        if (debounceTimer.current) {
            clearTimeout(debounceTimer.current);
        }
        debounceTimer.current = setTimeout(() => {
            if (!containerRef.current)
                return;
            const { scrollTop } = containerRef.current;
            const scrolledToTop = scrollTop === 0;
            if (scrolledToTop) {
                if (totalPages === page)
                    return;
                setPage((oldPage) => oldPage + 1);
            }
        }, 200);
    }, [totalPages, page]);
    useEffect(() => {
        const container = containerRef.current;
        if (container)
            container.addEventListener("scroll", handleScroll);
        return () => {
            if (container)
                container.removeEventListener("scroll", handleScroll);
        };
    }, [handleScroll, data]);
    useEffect(() => {
        let prevScrollHeight = 0;
        let prevScrollTop = 0;
        if (containerRef.current) {
            prevScrollHeight = containerRef.current.scrollHeight;
            prevScrollTop = containerRef.current.scrollTop;
        }
        if (newData) {
            setData((oldData) => {
                const seen = new Set(oldData.map((i) => i._id));
                const newMessages = newData?.filter((i) => !seen.has(i._id));
                if (shouldReverse) {
                    const newDataArray = Array.isArray(newMessages)
                        ? [...newMessages]
                        : [newMessages];
                    return [...newDataArray.reverse(), ...oldData];
                }
                else {
                    return [...newMessages, ...oldData];
                }
            });
        }
        requestAnimationFrame(() => {
            if (containerRef.current) {
                const newScrollTop = prevScrollTop + containerRef.current.scrollHeight - prevScrollHeight;
                containerRef.current.scrollTop = newScrollTop;
            }
        });
    }, [newData]);
    return { data, setData };
};

const Pagination = ({ totalPages = 1, currPage, setCurrPage, activeButtonStyle = {
    backgroundColor: "black",
    color: "white",
}, Button = ({ children, onClick, style }) => (React.createElement("button", { style: {
        padding: "0.5rem 1rem",
        outline: "none",
        border: "none",
        borderRadius: "0.5rem",
        cursor: "pointer",
        backgroundColor: "#e2e8f0",
        ...style,
    }, onClick: onClick }, children)), Container = ({ children }) => (React.createElement("ul", { style: {
        display: "flex",
        gap: "1rem",
        listStyle: "none",
    } }, children)), }) => {
    const [startPage, setStartPage] = useState(1);
    const maxPageButtons = 4;
    const changePage = (page) => {
        setCurrPage(page);
        if (page > startPage + maxPageButtons - 1) {
            setStartPage(page);
        }
        else if (page < startPage) {
            setStartPage(page - maxPageButtons + 1);
        }
    };
    return (React.createElement(Container, null,
        React.createElement(React.Fragment, null,
            startPage > 1 && (React.createElement("li", null,
                React.createElement(Button, { onClick: () => setStartPage((prev) => prev - maxPageButtons) }, "Prev"))),
            Array.from({ length: Math.min(maxPageButtons, totalPages) }, (_, idx) => startPage + idx).map((page) => {
                return (React.createElement("li", { key: page },
                    React.createElement(Button, { style: currPage === page ? activeButtonStyle : {}, onClick: () => changePage(page) }, page)));
            }),
            totalPages > startPage + maxPageButtons - 1 && (React.createElement("li", null,
                React.createElement(Button, { onClick: () => setStartPage((prev) => prev + maxPageButtons) }, "Next"))))));
};

const PageStepper = ({ totalPages = 1, currPage, setCurrPage, Typography = ({ children }) => React.createElement("code", null, children), Button, Container = ({ children }) => (React.createElement("nav", { style: {
        display: "flex",
        alignItems: "center",
        gap: "1rem",
        padding: "1rem 0",
    } }, children)), }) => {
    const isPreviousDisabled = currPage === 1;
    const isNextDisabled = currPage === totalPages;
    const handlePreviousClick = () => {
        if (currPage === 1)
            return;
        setCurrPage((prev) => prev - 1);
    };
    const handleNextClick = () => {
        if (currPage === totalPages)
            return;
        setCurrPage((prev) => prev + 1);
    };
    return (React.createElement(Container, null,
        React.createElement(React.Fragment, null,
            React.createElement(Button, { disabled: isPreviousDisabled, onClick: handlePreviousClick }, "Previous"),
            React.createElement(Typography, null,
                currPage,
                " of ",
                totalPages),
            React.createElement(Button, { disabled: isNextDisabled, onClick: handleNextClick }, "Next"))));
};

const MyntraCarousel = ({ images, darkMode = false, objectFit = "cover", setIsOpen, PrevButton, NextButton, }) => {
    const [activeImage, setActiveImage] = useState(0);
    const containerRef = useRef(null);
    const imageRef = useRef(null);
    const border = darkMode ? "1px solid #fff" : "1px solid black";
    const incrementHandler = () => {
        if (activeImage === images.length - 1)
            setActiveImage(0);
        else
            setActiveImage((prev) => prev + 1);
    };
    const decrementHandler = () => {
        if (activeImage === 0)
            setActiveImage(images.length - 1);
        else
            setActiveImage((prev) => prev - 1);
    };
    const mouseMoveHandler = useCallback((e) => {
        const y = e.clientY;
        containerRef.current?.scrollTo({ top: y });
    }, []);
    const closeHandler = (e) => {
        if (!containerRef.current)
            return;
        const containerDimension = containerRef.current.getBoundingClientRect();
        if (e.clientX < containerDimension.left ||
            e.clientX > containerDimension.right ||
            e.clientY < containerDimension.top ||
            e.clientY > containerDimension.bottom)
            setIsOpen(false);
    };
    useEffect(() => {
        if (containerRef.current)
            containerRef.current.addEventListener("mousemove", mouseMoveHandler);
        return () => {
            if (containerRef.current)
                containerRef.current.removeEventListener("mousemove", mouseMoveHandler);
        };
    }, []);
    const ImagesList = (React.createElement("aside", { style: {
            display: "flex",
            flexDirection: "column",
            gap: "1rem",
            position: "absolute",
            top: "1rem",
            left: "1rem",
        } }, images.map((i, idx) => (React.createElement("button", { key: idx, style: {
            border: idx === activeImage ? border : "1px solid rgba(0,0,0,0.3)",
            outline: "none",
            backgroundColor: "transparent",
            width: "fit-content",
            height: "unset",
            cursor: "pointer",
        }, onClick: () => setActiveImage(idx) },
        React.createElement("img", { style: {
                width: "2rem",
                height: "2.5rem",
                objectFit: "contain",
            }, src: i, alt: "Image" }))))));
    const NavigationButton = (React.createElement("article", { style: {
            display: "flex",
            width: "95%",
            justifyContent: "space-between",
            alignItems: "center",
            position: "absolute",
            top: "50%",
            left: "50%",
            transform: "translate(-50%,-50%)",
        } },
        React.createElement(PrevButton, { onClick: decrementHandler }),
        React.createElement(NextButton, { onClick: incrementHandler })));
    return (React.createElement("section", { style: {
            width: "100vw",
            height: "100vh",
            backgroundColor: "rgba(0,0,0,0.7)",
            position: "fixed",
            top: 0,
            left: 0,
            zIndex: 200,
        }, onClick: closeHandler },
        React.createElement("div", { style: {
                width: "100%",
                maxWidth: "950px",
                height: "100vh",
                position: "relative",
                margin: "auto",
                boxShadow: darkMode ? "0 0 5px black" : "0 0 5px white",
                overflow: "auto",
                cursor: "s-resize",
                scrollbarWidth: "none",
                backgroundColor: darkMode ? "black" : "#fff",
            }, ref: containerRef },
            React.createElement("img", { ref: imageRef, src: images[activeImage], style: {
                    width: "100%",
                    minHeight: "100vh",
                    objectFit,
                } }),
            React.createElement("div", { style: {
                    position: "fixed",
                    top: 0,
                    width: "95%",
                    maxWidth: "950px",
                    height: "100vh",
                } },
                ImagesList,
                NavigationButton))));
};
const StylishCarousel = ({ imageSize = ["100%", "80vw", "25rem", "30rem"], images = [], objectFit = "cover", imageBg = "transparent", sideImageSize = ["3rem", "3.5rem", "4rem", "5rem"], }) => {
    if (images.length === 0)
        throw new Error("imageSize should not be more than 4");
    if (imageSize.length > 5)
        throw new Error("imageSize should not be more than 4");
    const [activeImage, setActiveImage] = useState(0);
    const [currentWidth, setCurrentWidth] = useState("");
    const [sideImageWidth, setSideImageWidth] = useState("");
    const resizeHandler = useCallback(() => {
        const width = window.screen.width;
        if (width < 480) {
            setCurrentWidth(imageSize[0]);
            setSideImageWidth(sideImageSize[0]);
        }
        else if (width < 768 && imageSize.length >= 3) {
            setCurrentWidth(imageSize[1]);
            setSideImageWidth(sideImageSize[1]);
        }
        else if (width < 992 && imageSize.length >= 4) {
            setCurrentWidth(imageSize[2]);
            setSideImageWidth(sideImageSize[2]);
        }
        else if (width < 1280 && imageSize.length >= 5) {
            setCurrentWidth(imageSize[3]);
            setSideImageWidth(sideImageSize[3]);
        }
        else {
            setCurrentWidth(imageSize[imageSize.length - 1]);
            setSideImageWidth(sideImageSize[sideImageSize.length - 1]);
        }
    }, []);
    useEffect(() => {
        resizeHandler();
        window.addEventListener("resize", resizeHandler);
        return () => {
            window.removeEventListener("resize", resizeHandler);
        };
    }, []);
    return (React.createElement("div", { style: {
            width: "fit-content",
            display: "flex",
            gap: "1rem",
            padding: "1rem",
        } },
        React.createElement("aside", { style: {
                display: "flex",
                flexDirection: "column",
                width: "fit-content",
                gap: "1rem",
            } }, images.map((i, index) => (React.createElement("img", { key: index, style: {
                width: sideImageWidth,
                height: sideImageWidth,
                borderRadius: "0.25rem",
                objectFit,
                border: "1px solid  rgba(0,0,0,0.3)",
            }, src: i, alt: `Image-${index}`, onMouseOver: () => setActiveImage(index) })))),
        React.createElement("section", { style: {
                width: currentWidth,
                height: currentWidth,
                overflow: "hidden",
                scrollbarWidth: "none",
                display: "flex",
                alignItems: "center",
                borderRadius: "0.5rem",
                backgroundColor: imageBg,
            } }, images.map((i, index) => (React.createElement("img", { key: index, style: {
                width: currentWidth,
                height: currentWidth,
                objectFit: "contain",
                aspectRatio: "1/1",
                borderRadius: "0.5rem",
                transition: "all 0.3s",
                transform: `translateX(-${activeImage * 100}%)`,
            }, src: i, alt: `Photo-${index}` }))))));
};
const Slider = ({ images, objectFit = "cover", PrevIcon, NextIcon, bgColor = "inherit", showNav = true, showDots, showThumbnails, autoplay, autoplayDuration = 4000, onClick, }) => {
    const [activeImage, setActiveImage] = useState(0);
    const incrementHandler = () => {
        setActiveImage((prev) => {
            if (prev === images.length - 1)
                return 0;
            return prev + 1;
        });
    };
    const decrementHandler = () => {
        setActiveImage((prev) => {
            if (prev === 0)
                return images.length - 1;
            return prev - 1;
        });
    };
    useEffect(() => {
        let intervalId;
        if (autoplay) {
            intervalId = setInterval(() => {
                incrementHandler();
            }, autoplayDuration);
        }
        return () => {
            if (intervalId)
                clearInterval(intervalId);
        };
    }, []);
    const NavigationButton = (React.createElement("article", { style: {
            padding: "1rem",
            position: "absolute",
            display: "flex",
            alignItems: "center",
            justifyContent: "space-between",
            width: "100%",
            top: "50%",
            transform: "translateY(-50%)",
        } },
        React.createElement("button", { style: {
                border: "none",
                backgroundColor: "transparent",
                cursor: "pointer",
                outline: "none",
            }, onClick: decrementHandler }, PrevIcon || "Prev"),
        React.createElement("button", { style: {
                border: "none",
                backgroundColor: "transparent",
                cursor: "pointer",
                outline: "none",
            }, onClick: incrementHandler }, NextIcon || "Next")));
    const Dots = (React.createElement("article", { style: {
            padding: "1rem",
            position: "absolute",
            display: "flex",
            alignItems: "center",
            justifyContent: "center",
            width: "100%",
            bottom: 0,
            gap: "0.5rem",
        } }, images.map((_, idx) => (React.createElement("button", { key: idx, style: {
            width: "0.75rem",
            height: "0.75rem",
            borderRadius: "50%",
            border: "none",
            backgroundColor: idx === activeImage ? "white" : "black",
        }, onClick: () => setActiveImage(idx) })))));
    const Thumbnails = (React.createElement("aside", { style: {
            height: "5rem",
            display: "flex",
            justifyContent: "center",
            gap: "1rem",
            flexWrap: "wrap",
        } }, images.map((i, index) => (React.createElement("img", { key: index, style: {
            width: "5rem",
            height: "5rem",
            borderRadius: "0.25rem",
            objectFit: "cover",
            border: "1px solid  rgba(0,0,0,0.3)",
        }, src: i, alt: `Image-${index}`, onMouseOver: () => setActiveImage(index) })))));
    return (React.createElement("div", { style: {
            height: "100%",
            display: "flex",
            flexDirection: "column",
            gap: "1rem",
            backgroundColor: bgColor,
        } },
        React.createElement("div", { style: {
                height: "100%",
                display: "flex",
                overflowX: "hidden",
                position: "relative",
            } },
            images.map((i, index) => (React.createElement("img", { key: index, style: {
                    width: "100%",
                    height: "100%",
                    objectFit,
                    flex: "none",
                    transition: "all 0.3s",
                    transform: `translateX(-${activeImage * 100}%)`,
                }, src: i, onClick: () => onClick && onClick() }))),
            showNav && NavigationButton,
            showDots && Dots),
        showThumbnails && Thumbnails));
};

const FireBolt = memo(({ size = 10, color = "black", styles, zoom = "2", mode = "normal", }) => {
    if (size < 1 || size > 40) {
        throw new Error("Size must be between 1 and 40");
    }
    const circles = useRef();
    const coordinates = useRef({ x: 0, y: 0 });
    const fireBoltZoomRef = useRef(false);
    const handleMouseMove = (e) => {
        coordinates.current = {
            x: e.clientX,
            y: e.clientY,
        };
        const target = e.target;
        const fireboltZoom = target.getAttribute("data-firebolt-zoom");
        fireBoltZoomRef.current = Boolean(fireboltZoom);
    };
    const animateCircles = useCallback(() => {
        let x = coordinates.current.x;
        let y = coordinates.current.y;
        const cursors = circles.current;
        if (!cursors) {
            return;
        }
        Array.from(cursors).forEach((circle, idx) => {
            circle.style.left = `${x - 12}px`;
            circle.style.top = `${y - 12}px`;
            circle.x = x;
            circle.y = y;
            const newSize = (cursors.length - idx) / cursors.length;
            circle.style.scale = newSize.toString();
            const nextCircle = cursors[idx + 1] || cursors[0];
            x += (Number(nextCircle.x || 0) - x) * 0.3;
            y += (Number(nextCircle.y || 0) - y) * 0.3;
            if (idx === 0 && fireBoltZoomRef.current) {
                circle.style.scale = zoom;
            }
        });
        requestAnimationFrame(animateCircles);
    }, []);
    useEffect(() => {
        circles.current = document.getElementsByClassName("6pp-firebolt-Cursor");
        animateCircles();
        window.addEventListener("mousemove", handleMouseMove);
        return () => {
            window.removeEventListener("mousemove", handleMouseMove);
        };
    }, []);
    return (React.createElement("div", { style: {
            zIndex: "10000",
            mixBlendMode: mode,
            pointerEvents: "none",
        } }, Array.from({ length: size }).map((_, i) => (React.createElement("div", { className: "6pp-firebolt-Cursor", key: i, style: {
            position: "fixed",
            height: "24px",
            width: "24px",
            borderRadius: "50%",
            left: 0,
            top: 0,
            backgroundColor: color,
            userSelect: "none",
            pointerEvents: "none",
            transition: "scale 0.2s",
            ...styles,
        } })))));
});

export { FireBolt, MyntraCarousel, PageStepper, Pagination, Slider, StylishCarousel, isDateBetween, isIncludeCapitalLetter, isIncludeLowercaseLetter, isIncludeNumber, isIncludeSpecialChar, isValidDate, isValidDateTime, isValidEmail, isValidPhoneNumber, isValidTime, isValidUrl, isValidUsername, useConfirmModal, useFetchData, useFileHandler, useInfiniteScrollBottom, useInfiniteScrollTop, useInputValidation, useRating, useStrongPassword };
